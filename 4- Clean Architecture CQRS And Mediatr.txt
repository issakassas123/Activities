*. Learning Goals
    *. Understand and apply the Clean Architecture pattern
    *. Implement the CQRS + Mediator pattern
    *. Create handlers for CRUD operations using MediatR

*. Clean Architecture Overview
    *. Concept
        A Clean Architecture separates concerns between layers, 
        ensuring the core logic is independent of external systems like databases or frameworks.

    *. Layer Diagram    
        +---------------------------------------------------------+
        | Circle 1: Frameworks & Drivers |
        | (Devices, Web, DB, UI, External Interfaces) |
        | --> Persistence Project & UI (React) |
        +---------------------------------------------------------+
        ↓ Depends on
        +---------------------------------------------------------+
        | Circle 2: Interface Adapters |
        | (Controllers, Gateways, Presenters) |
        | --> API Project |
        +---------------------------------------------------------+
        ↓ Depends on
        +---------------------------------------------------------+
        | Circle 3: Application Business Rules |
        | (Use Cases) |
        | --> Application Project |
        +---------------------------------------------------------+
        ↓ Depends on
        +---------------------------------------------------------+
        | Circle 4: Enterprise Business Rules |
        | (Entities, Core Logic) |
        | --> Domain Project |
        +---------------------------------------------------------+

    *. Data Flow:
        Presenter → Use Case Output Port ← Use Case Interactor → Use Case Input Port ← Controller

    *. Recommendations
        Independent from frameworks
        Highly testable
        Independent from interface or UI
        Independent from database or infrastructure

*. Mediator
    *. Core Concept
        Mediator handles communication between objects to reduce coupling.
        Controllers interact with the Mediator, not the data layer directly.
        Object Out → Mediator Handlers → API Controller → Mediator.Send()

*. CQRS & Mediator Pattern
    *. CQRS (Command Query Responsibility Segregation)
        Command	                    Query
        Performs an action	        Retrieves data
        Modifies state	            Does not modify state
        Should not return a value	Should return a value

    *. CQRS Architecture Diagram
        Single Database Architecture:
            API → Command → Domain → Persistence → DB
            DB → Data Access → Query → API

        Read/Write Split Architecture:
            API → Command → Domain → Persistence → Write DB
            Read DB (NoSQL) → Data Access → Query → API

    *. Mediator Overview
        Mediator acts as a central point for communication between objects.
        Reduces coupling between components.
        API Controllers send requests via Mediator.Send().

        *. Mediator Structure
            Controller → Mediator.Send(Command or Query) → Handler → Database (via DbContext)

*. Application Project Setup
    *. NuGet Packages
        MediatR & AutoMapper

    *. Directory Structure
        Application
        │
        ├── Activities
        │ ├── Commands
        │ │ ├── CreateActivity.cs
        │ │ ├── EditActivity.cs
        │ │ └── DeleteActivity.cs
        │ └── Queries
        │ ├── GetActivityList.cs
        │ └── GetActivityDetails.cs
        └── Core
        └── MappingProfiles.cs

        *. Adding a Mediator handler for a List. GetActivitiesList.cs
            using Domain;
            using MediatR;
            using Microsoft.EntityFrameworkCore;
            using Persistence;

            namespace Application.Activities.Queries;

            public class GetActivityList
            {
                public class Query : IRequest<List<Activity>> { }

                public class Handler(AppDbContext context) : IRequestHandler<Query, List<Activity>>
                {
                    public async Task<List<Activity>> Handle(Query request, CancellationToken cancellationToken)
                    {
                        return await context.Activities.ToListAsync(cancellationToken);
                    }
                    }
            }

        *. Adding a Mediator handler for the Details. GetActivityDetails.cs
            using Domain;
            using MediatR;
            using Persistence;

            namespace Application.Activities.Queries;

            public class GetActivityDetails
            {
                public class Query : IRequest<Activity>
                {
                    public required string Id { get; set; }
                }

                public class Handler(AppDbContext context) : IRequestHandler<Query, Activity>
                {
                    public async Task<Activity> Handle(Query request, CancellationToken cancellationToken)
                    {
                        var activity = await context.Activities.FindAsync([request.Id], cancellationToken) ??
                            throw new Exception("Activity not found");
                        return activity;
                    }
                }
            }

        *. Adding a Mediator handler for Creating an Acitivity. CreateActivity.cs
            using Domain;
            using MediatR;
            using Persistence;

            namespace Application.Activities.Commands;

            public class CreateActivity
            {
                public class Command : IRequest<string>
                {
                    public required Activity Acitivity { get; set; }
                }

                public class Handler(AppDbContext context) : IRequestHandler<Command, string>
                {
                    public async Task<string> Handle(Command request, CancellationToken cancellationToken)
                    {
                        await context.Activities.AddAsync(request.Acitivity, cancellationToken);
                        await context.SaveChangesAsync(cancellationToken);
                        return request.Acitivity.Id;
                    }
                }
            }

        *. Adding a Mediator handler for Editing an Acitivity. EditActivity.cs
            using AutoMapper;
            using Domain;
            using MediatR;
            using Persistence;

            namespace Application.Activities.Commands;

            public class EditActivity
            {
                public class Command : IRequest
                {
                    public required Activity Activity { get; set; }
                }

                public class Handler(AppDbContext context, IMapper mapper) : IRequestHandler<Command>
                {
                    public async Task Handle(Command request, CancellationToken cancellationToken)
                    {
                        var activity = await context.Activities.FindAsync([request.Activity.Id], cancellationToken)
                            ?? throw new Exception("Cannot find activity");

                        mapper.Map(request.Activity, activity);

                        await context.SaveChangesAsync(cancellationToken);
                        return;
                    }
                }
            }

        *. Adding a Mediator Delete handler. DeleteActivity.cs
            using MediatR;
            using Persistence;

            namespace Application.Activities.Commands;

            public class DeleteActivity
            {
                public class Command : IRequest
                {
                    public required string Id { get; set; }
                }

                public class Handler(AppDbContext context) : IRequestHandler<Command>
                {
                    public async Task Handle(Command request, CancellationToken cancellationToken)
                    {
                        var activity = await context.Activities.FindAsync([request.Id], cancellationToken)
                            ?? throw new Exception("Cannot find activity");

                        context.Activities.Remove(activity);
                        await context.SaveChangesAsync(cancellationToken);
                    }
                }
            }
        
        *. Adding AutoMapper Setup.
            *. MappingProfiles.cs
                using Domain;
                using AutoMapper;

                namespace Application.Core;

                public class MappingProfiles: Profile
                {
                    public MappingProfiles()
                    {
                        CreateMap<Activity, Activity>();
                    }
                }

    *. API Project Configuration
        *. NuGet Package
            MediatR
        *. Making the API Controllers thinner. BaseApiController.cs
            using MediatR;
            using Microsoft.AspNetCore.Mvc;

            namespace API.Controllers;

            [Route("api/[controller]")]
            [ApiController]
            public class BaseApiController : ControllerBase
            {
                private IMediator? _mediator;
                protected IMediator Mediator => _mediator ??= HttpContext.RequestServices.GetService<IMediator>()
                    ?? throw new InvalidOperationException("IMediator Service is unavailable");
            }

        *. ActivitiesController.cs
            using Application.Activities.Queries;
            using Application.Activities.Commands;
            using Domain;
            using Microsoft.AspNetCore.Mvc;

            namespace API.Controllers;

            public class ActivitiesController : BaseApiController
            {
                public async Task<ActionResult<List<Activity>>> GetActivities()
                {
                    return await Mediator.Send(new GetActivityList.Query());
                }

                [HttpGet("{Id}")]
                public async Task<Activity> GetActivityDetail(string Id)
                {
                    return await Mediator.Send(new GetActivityDetails.Query
                    {
                        Id = Id
                    });
                }

                [HttpPost]
                public async Task<ActionResult<string>> CreateActivity(Activity activity)
                {
                    return await Mediator.Send(new CreateActivity.Command
                    {
                        Acitivity = activity
                    });
                }

                [HttpPut]
                public async Task<ActionResult> EditActivity(Activity activity)
                {
                    await Mediator.Send(new EditActivity.Command
                    {
                        Activity = activity
                    });

                    return NoContent();
                }

                [HttpDelete("{Id}")]
                public async Task<ActionResult> DeleteActivity(string Id)
                {
                    await Mediator.Send(new DeleteActivity.Command
                    {
                        Id = Id
                    });

                    return Ok();
                }
            }

        *. Program.cs Configuration
            builder.Services.AddMediatR(
                config => config.RegisterServicesFromAssemblyContaining<GetActivityList.Handler>()
            );

            builder.Services.AddAutoMapper(cfg =>
            {
            }, typeof(MappingProfiles));

*. Using Cancellation Tokens
    Cancellation tokens allow graceful termination of long-running requests if the client cancels the operation. 
    This prevents unnecessary resource use

*. Debugging in .NET
    Steps
        Open Run and Debug in VS Code.
        Create a launch.json file.
        Add configurations:
            {
                // Use IntelliSense to learn about possible attributes.
                // Hover to view descriptions of existing attributes.
                // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
                "version": "0.2.0",
                "configurations": [
                    {
                        "name": "C#: API Debug",
                        "type": "dotnet",
                        "request": "launch",
                        "projectPath": "${workspaceFolder}/API/API.csproj"
                    },
                    {
                        "name": ".NET Core Attach",
                        "type": "coreclr",
                        "request": "attach"
                    }
                ]
            }

*. FAQ
    Q: Can I use NoSQL (e.g., MongoDB) with EF Core?
    A: No, EF Core is designed for relational databases. 
    For NoSQL, use their native APIs (e.g., MongoDB, Azure Cosmos DB, CouchDB, Cassandra, RavenDB).

*. Summary Diagram
    +-----------------------+ +----------------------+ +------------------+
    | React Frontend UI | <---> | API (Mediator) | <---> | Application & |
    | (Vite + TypeScript) | | (Controllers, CQRS) | | Persistence DB |
    +-----------------------+ +----------------------+ +------------------+